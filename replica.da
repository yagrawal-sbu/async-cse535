import re
import time
import pickle
import nacl.encoding
import nacl.signing

# define the replica process
class Node(process):


############################################
#  Necessary functions setup and run
############################################

  # define the setup for the client
  def setup(replica_type, pre, post, fault_tolerance_factor, replica_sign_key, sign_verify_keys, replica_timeout_value, client_public_keys, config_ID, myPosition, replica_sequence):
    self.myReplicaType = replica_type
    self.pre = pre
    self.post = post
    self.my_private_key = replica_sign_key
    self.sign_verify_keys = sign_verify_keys
    self.replica_timeout_value = replica_timeout_value
    self.client_public_keys = client_public_keys
    self.config_ID = config_ID
    self.myPosition = myPosition
    self.replica_sequence = replica_sequence

    self.objDict = {}
    self.result_cache = {}
    self.response_cache = {}
    self.slot = 0
    self.timeout = {}


  # main execution flow of the client
  def run():

    while(True):

      # messages from olympus get higher priority
      --olympus_to_replica
      --client_to_replica
      --replica_to_replica

      # check the timeout array for any timeout
      for key, value in timeout.items():
        now = time.time()
        difference = int(now - value)
        if(difference > replica_timeout_value):
          send(('Reconfig_Request'), to=olympus)
          pass



############################################
#  Helper Functions
############################################
  def getByteForm(string, encoding_format='utf-8'):
    return bytes(string, encoding=encoding_format)

  def doWork(work):
    # matchObj = re.match( r'\s*(put|get|slice|append)\(\'(.*)\'(,|.)\s*(\'|.)(.*)\'\)\s*', work)
    matchObj = re.match( r'\s*(put|get|append|slice)\((.*)\)\s*', work)
    print( "operation= " + matchObj.group(1) + " , operand(s)= " + matchObj.group(2) )

    # if no valid operation or first operator is found
    if( (not matchObj.group()) or (not matchObj.group(1)) or (not matchObj.group(2)) ):
      return 'fail'

    operand_str = matchObj.group(2).strip()

    if(matchObj.group(1) == 'put'):
      matchObj = re.match( r'\'(.*)\'\s*,\s*\'(.*)\'', operand_str)
      objDict[matchObj.group(1)] = matchObj.group(2)
      return 'OK'

    if(matchObj.group(1) == 'get'):
      matchObj = re.match( r'\'(.*)\'.*', operand_str)
      if( not objDict[ matchObj.group(1) ] ):
        return ''
      else:
        return objDict[matchObj.group(1)]

    if(matchObj.group(1) == 'append'):
      matchObj = re.match( r'\'(.*)\'\s*,\s*\'(.*)\'', operand_str)
      if( not objDict[ matchObj.group(1) ] ):
        return 'fail'
      else:
        objDict[ matchObj.group(1) ] += matchObj.group(2)
        return 'OK'

    if(matchObj.group(1) == 'slice'):
      matchObj = re.match( r'\'(.*)\'\s*,\s*\'(.*)\'', operand_str)
      if( not objDict[ matchObj.group(1) ] ):
        return 'fail'
      else:
        # TODO, add valid slice length check here
        indicesObj = re.match( r'(.*):(.*)', matchObj.group(2))
        index1 = int( indicesObj.group(1) )
        index2 = int( indicesObj.group(2) )
        objDict[ matchObj.group(1) ] = objDict[ matchObj.group(1) ][ index1:index2 ]
        return 'OK'

    return ''

  def getSigned(string):
    return my_private_key.sign( string )

  def cryptoEncode(string):
    return nacl.encoding.HexEncoder.encode( getByteForm(string) )

  def create_shuttle_object(workload):
    slot += 1           # head should increment this
    shuttle_object = {
      'slot': slot,
      'client_workload': workload,
      'order_proof': {
        'slot': slot,
        'operation': workload['operation'],
        'configID': config_ID,
        'order_statements': []
      },
      'result_proof': {
        'operation': workload['operation'],
        'result_hashes': []
      }
    }
    return shuttle_object

  def addMyStatements(shuttle_object, result):
    operation = shuttle_object['client_workload']['operation']
    my_order_statement = {
      'slot': slot,
      'operation': operation
    }
    my_result_hash = {
      'operation': operation,
      'result_hash': cryptoEncode(result)
    }
    shuttle_object['order_proof']['order_statements'].append( getSigned( pickle.dumps(my_order_statement) ) )
    shuttle_object['result_proof']['result_hashes'].append( getSigned( pickle.dumps(my_result_hash) ) )

  def validateShuttleObject( shuttle_object, shuttle_type='forward'):

    if(shuttle_type == 'forward'):
      # 1. look for slot holes
      if( shuttle_object['slot'] != slot+1 ):
        print("Found hole in slot.")
        return False

    # 2. validate size of both proofs same or not
    order_statements = shuttle_object['order_proof']['order_statements']
    result_hashes = shuttle_object['result_proof']['result_hashes']
    if( len(order_statements) != len(result_hashes) ):
      print("Size of order_proof and result_proof arrays do not match.")
      return False

    # 3. validate signature and then contents
    common_result_hash = b''
    common_slot = 0
    common_operation = ''
    for counter in range(0, len(order_statements)):
      # validate signature first
      public_key = sign_verify_keys[counter]
      try:
        decrypted_order_stat = public_key.verify( order_statements[counter] )
        decrypted_res_hsh = public_key.verify( result_hashes[counter] )
      except nacl.exceptions.BadSignatureError:
        print("Signature of replica '"+str(counter)+"'' did not match.")
        return False

      # validate the order statement
      unpickled_order_stat = pickle.loads(decrypted_order_stat)
      if(counter == 0):
        common_slot = unpickled_order_stat['slot']
        common_operation = unpickled_order_stat['operation']
      else:
        if(unpickled_order_stat['slot'] != common_slot):
          print("Slot in order statement of replica '"+str(counter)+"'' did not match.")
          return False
        if(unpickled_order_stat['operation'] != common_operation):
          print("Operation in order statement of replica '"+str(counter)+"'' did not match.")
          return False

      # validate the result statement
      unpickled_result_hash = pickle.loads(decrypted_res_hsh)['result_hash']
      if(counter == 0):
        common_result_hash = unpickled_result_hash
      else:
        if(unpickled_result_hash != common_result_hash):
          print("Result hash in result statement of replica '"+str(counter)+"'' did not match.")
          return False

    # if control reaches here, means valid shuttle
    # do necessary operations
    if(shuttle_type == 'forward'):
      slot += 1

    return True

  def clientUnsignWorkload(workload):
    if workload['requester'] in client_public_keys:
      public_key = client_public_keys[ workload['requester'] ]
      try:
        decrpyted_workload = public_key.verify(workload['encrypted_workload'])
      except nacl.exceptions.BadSignatureError:
        print("Signature of client did not match.")
        return False
      unpickled_workload = pickle.loads(decrpyted_workload)
      unpickled_workload['requester'] = workload['requester']
      print(unpickled_workload)
    else:
      print("No public key found for client's request")
      return False
    return unpickled_workload

  def create_cli_res_obj(shuttle_object, result):
    client_response_object = {
      'client_workload': shuttle_object['client_workload'],
      'result': result,
      'result_proof': shuttle_object['result_proof']['result_hashes']
    }
    return client_response_object

  def create_reverse_shuttle_object( shuttle_object ):
    return shuttle_object

  def addToResultCache(request_id, result):
    result_cache[request_id] = result

  def cacheWorkload( reverse_shuttle_object ):
    client_workload_id = reverse_shuttle_object['client_workload']['id']
    result = result_cache[ client_workload_id ]
    del result_cache[ client_workload_id ]
    client_response_object = create_cli_res_obj(reverse_shuttle_object, result)
    response_cache[ client_workload_id ] = client_response_object

  def inResultCache( workload ):
    return workload['id'] in result_cache

  def inCache( workload ):
    return workload['id'] in response_cache

  def addToTimeOut( workload ):
    timeout[ workload['id'] ] = time.time()

  def presentInTimeOut( reverse_shuttle_object ):
    return reverse_shuttle_object['client_workload']['id'] in timeout

  def deleteEntryInTimeOut( workload_id ):
    del timeout[ workload_id ]

############################################
#  Received messages handler
############################################

  # handle operation requests from client
  def receive( msg=('Operation', encrypted_workload), from_=client ):
    output("Received operation request from client.")
    # decrypt workload
    workload = clientUnsignWorkload(encrypted_workload)
    if(not workload):
      print("Signature not verified for client workload.")
      return

    # check if workload is a retransmission
    if( workload['retransmit'] ):
      # first check with workload id if this request is in cache
      if inCache(workload) or inResultCache(workload):
        # can reply to client directly
        if( inCache(workload) ):
          client_response_object = inCache( workload )
          send(('Operation_Response', client_response_object), to=client_response_object['client_workload']['requester'])
          output("Sent retransmitted Operation_Response to client.")
          return
        # still waiting to receive the result shuttle
        if( inResultCache(workload) ):
          # add request to timeout DS
          addToTimeOut( workload )
          return
    else:
      if(myReplicaType=="HEAD"):
        result = doWork(workload['operation'])
        shuttle_object = create_shuttle_object(workload)
        addMyStatements(shuttle_object, result)
        addToResultCache( workload['id'], result )
        if( post is None ):
          client_response_object = create_cli_res_obj(shuttle_object, result)
          send(('Operation_Response', client_response_object), to=client_response_object['client_workload']['requester'])
          output("Sent Operation_Response to client.")
          cacheWorkload( shuttle_object )
        else:
          send(('Shuttle', shuttle_object), to=post)
          output("Sent Shuttle to next node.")
      else:
        output('Forwarded request from client to head replica.')
        send(('Operation', encrypted_workload), to=replica_sequence[0])


  # handle shuttle messages from other replicas
  def receive( msg=('Shuttle', shuttle_object), from_=replica_set ):
    output("["+str(myPosition)+"] Received Shuttle slot="+ str(shuttle_object['slot']) +", from previous replica.")

    # validate shuttle first
    if( not validateShuttleObject(shuttle_object) ):
      send(('Reconfig_Request'), to=olympus)
      return

    # perform the operation and get the result
    result = doWork(shuttle_object['client_workload']['operation'])
    # check if result matches with the crypto hash
    addMyStatements(shuttle_object, result)
    addToResultCache( shuttle_object['client_workload']['id'], result )

    # take further action based on replica type
    if( myReplicaType=='TAIL' ):
      # send response to client
      client_response_object = create_cli_res_obj(shuttle_object, result)
      send(('Operation_Response', client_response_object), to=client_response_object['client_workload']['requester'])
      output("Sent Operation_Response to client.")

      # start reverse shuttle
      reverse_shuttle_object = create_reverse_shuttle_object( shuttle_object )
      cacheWorkload( reverse_shuttle_object )
      send(('Reverse_Shuttle', reverse_shuttle_object), to=pre)
      output("Sent Reverse_Shuttle to previous node.")
    else:
      # inner node will forward shuttle to succeding replica
      send(('Shuttle', shuttle_object), to=post)
      output("Sent Shuttle to next node.")

  # handle reverse shuttle messages from other replicas
  def receive( msg=('Reverse_Shuttle', reverse_shuttle_object), from_=replica_set ):
    output("Received Reverse_Shuttle slot="+ str(reverse_shuttle_object['slot']) +", from next replica.")

    # validate shuttle first
    if( not validateShuttleObject(reverse_shuttle_object, shuttle_type='reverse') ):
      send(('Reconfig_Request'), to=olympus)
      return

    # cache the workload for retransmit in future
    cacheWorkload( reverse_shuttle_object )

    # also check if this operation is in timeout handler array
    if( presentInTimeOut(reverse_shuttle_object) ):
      client_response_object = inCache( reverse_shuttle_object['client_workload'] )
      send(('Operation_Response', client_response_object), to=client_response_object['client_workload']['requester'])
      output("Sent retransmitted Operation_Response to client.")
      deleteEntryInTimeOut( reverse_shuttle_object['client_workload']['id'] )

    # forward to previous replica, if not head
    if( myReplicaType!='HEAD' and pre ):
      send(('Reverse_Shuttle', reverse_shuttle_object), to=pre)
      output("Sent Reverse_Shuttle to previous node.")

