import nacl.encoding
import nacl.signing

# define the master process
class Node(process):


############################################
# Necessary functions setup and run
############################################
  # define the setup for the master
  def setup(fault_tolerance_factor, replica_set, head_timeout, nonhead_timeout, client_public_keys, client_seq_no, failures, config):
    self.fault_tolerance_factor = fault_tolerance_factor
    self.replica_sequence       = []
    self.replica_set            = replica_set
    self.sign_keys              = []
    self.sign_verify_keys       = []
    self.head_timeout           = head_timeout
    self.nonhead_timeout        = nonhead_timeout
    self.client_public_keys     = client_public_keys
    self.config_ID              = -1
    self.client_seq_no          = client_seq_no
    self.failures               = failures


  # main execution flow for the master
  def run():
    startReplicas()
    while(True):
      --replica_to_olympus
      --client_to_olympus


############################################
#  Helper Functions
############################################
  # get the failure, given a config and replica position
  def getFailure(config_ID, replica_ID):
    if( not config_ID in failures.keys() ):
      return None
    if( not replica_ID in failures[config_ID].keys() ):
      return None
    return failures[config_ID][replica_ID]

  # start the replicas
  def startReplicas():
    config_ID += 1  # increase the configID
    replicas_required = 2*fault_tolerance_factor + 1

    for replica_id in set(replica_set):
      signing_key = nacl.signing.SigningKey.generate()
      verify_key_hex = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
      verify_key = nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)
      replica_sequence.append(replica_id)
      sign_keys.append(signing_key)
      sign_verify_keys.append(verify_key)


    counter = 0
    for replica_id, replica_sign_key in zip(replica_sequence, sign_keys):
      # default conditions, used when only one node present
      replica_type = "HEAD"
      pre = None
      post = None
      replica_timeout_value = head_timeout
      if( len(replica_sequence) > 1 ):
        if (counter==0):
          post = replica_sequence[counter+1]
        if (counter==replicas_required-1):
          replica_type = "TAIL"
          replica_timeout_value = nonhead_timeout
          pre = replica_sequence[counter-1]
        if (counter>0 and counter<replicas_required-1):
          replica_type = "INNER"
          replica_timeout_value = nonhead_timeout
          pre = replica_sequence[counter-1]
          post = replica_sequence[counter+1]
      failure = getFailure(config_ID, counter)
      setup(replica_id, (self, replica_type, pre, post, fault_tolerance_factor, replica_sign_key, sign_verify_keys, replica_timeout_value, client_public_keys, config_ID, counter, replica_sequence, client_seq_no, failure, config) )
      start(replica_id)
      counter += 1

    output(str(replicas_required) + " replica(s) started by Olympus.\n\n")

############################################
#  Received messages handler
############################################
  def receive(msg=('GetConfig',), from_=client):
    output("Received GetConfig request from a client.")
    send(('GetConfig_Response', replica_sequence, sign_verify_keys), to=client)
    output("Sent GetConfig_Response to client.")
    output("Replica sequence sent = ", replica_sequence)
    output("Public Keys sent = ", sign_verify_keys, "\n\n")

  def receive(msg=('Reconfig_Request',), from_=replica_set):
    output("Received Reconfig_Request request from a replica.\n\n")
    send(('Wedge_Request'), to=replica_sequence)

  def receive(msg=('Reconfig_Request', proof), from_=client):
    output("Received Reconfig_Request request from a client.\n\n")
    # verify the proof of misbehavior
    send(('Wedge_Request'), to=replica_sequence)

