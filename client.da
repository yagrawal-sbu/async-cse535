import re
import uuid
import time
import pickle

# define the client process
class Node(process):

############################################
# Necessary functions setup and run
############################################
  # define the setup for the client
  def setup(olympus, private_key, workload_string, client_timeout):
    self.olympus = olympus
    self.replica_sequence = ()
    self.sequence_head = False
    self.operations_array = partitionWorkLoad( workload_string )
    self.client_timeout = client_timeout
    self.timeout = {}
    self.sign_verify_keys = []
    self.private_key = private_key

  # main execution flow of the client
  def run():
    if not replica_sequence:
      send(('GetConfig',), to=olympus)
      output("Sent GetConfig request to olympus.")
    while(True):
      # check if any entry in timeout_array has expired
      for key, value in timeout.items():
        now = time.time()
        difference = int(now - value['time'])
        if(difference > client_timeout):
          #send to all nodes
          workload = timeout[key]['workload']
          workload['retransmit'] = True
          send(('Operation', workload), to=replica_sequence)
          output("Sent operation request to replica")
          #reset the timer
          timeout[key]['time'] = time.time()
          pass

      # yield point to receive messages
      --accept_msgs

      # send operation request to replica head
      if replica_sequence and operations_array:
        workload = create_workload_object(operations_array[0])
        operations_array.pop(0)
        send(('Operation', workload), to=sequence_head)
        output("Sent operation request to replica")
        addToTimeOut( workload )        # append to timeout array with timestamp


############################################
#  Helper Functions
############################################
  # add client unique identifier
  # add own address
  def create_workload_object(operation):
    print(operation)
    workload_to_be_encrpyted = {
      'id': uuid.uuid4().hex,
      'operation': operation,
      'retransmit': False
    }
    final_workload = {
      'requester': self,
      'id': workload_to_be_encrpyted['id'],
      'retransmit': workload_to_be_encrpyted['retransmit'],
      'encrypted_workload': private_key.sign( pickle.dumps(workload_to_be_encrpyted) )
    }
    return final_workload

  def validateResponse( client_response_object ):

    result_hashes = client_response_object['result_proof']
    if( len(result_hashes) != len(replica_sequence) ):
      print("Result hashes count does not match replicas count.")
      return False

    common_result_hash = b''
    common_operation = ''
    for counter in range(0, len(result_hashes)):
      # validate signature first
      public_key = sign_verify_keys[counter]
      try:
        decrypted_res_hsh = public_key.verify( result_hashes[counter] )
      except nacl.exceptions.BadSignatureError:
        print("Signature of replica '"+str(counter)+"'' did not match.")
        return False

      # validate the result statement
      unpickled_result_hash = pickle.loads(decrypted_res_hsh)['result_hash']
      if(counter == 0):
        common_result_hash = unpickled_result_hash
      else:
        if(unpickled_result_hash != common_result_hash):
          print("Result hash in result statement of replica '"+str(counter)+"'' did not match.")
          return False
    return True

  def getPseudoRandomWorkLoad(seed, count):
    print(seed)
    print(count)
    return []

  def partitionWorkLoad(workload_string):
    workload_array = workload_string.split(';')
    workload_array = [x.strip(' ') for x in workload_array]
    if('pseudorandom' in  workload_array[0]):
      matchObj = re.match( r'\s*pseudorandom\(\s*(.*)\s*,\s*(.*)\s*\)', workload_array[0])
      workload_array = getPseudoRandomWorkLoad( matchObj.group(1), matchObj.group(2) )
    return workload_array

  def addToTimeOut( workload ):
    timeout[ workload['id'] ] = {
      'time': time.time(),
      'workload': workload
    }

  def presentInTimeOut( client_response_object ):
    return client_response_object['client_workload']['id'] in timeout

  def deleteEntryInTimeOut( workload_id ):
    del timeout[ workload_id ]

############################################
#  Received messages handler
############################################
  def receive(msg=('GetConfig_Response', replica_sequence, sign_verify_keys), from_=olympus):
    output("Received GetConfig_Response from olympus.")
    self.replica_sequence = replica_sequence
    self.sequence_head    = replica_sequence[0]
    self.sign_verify_keys = sign_verify_keys

  def receive(msg=('Operation_Response', client_response_object), from_=replica_sequence):
    output("Received Operation_Response from replica.")

    # validate response
    if( not validateResponse(client_response_object) ):
      #send reconfig request to Olympus
      return

    if( presentInTimeOut(client_response_object) ):
      deleteEntryInTimeOut( client_response_object['client_workload']['id'] )
      output("Removed from timeout.")
    print(client_response_object['result'])
    # print(client_response_object)
